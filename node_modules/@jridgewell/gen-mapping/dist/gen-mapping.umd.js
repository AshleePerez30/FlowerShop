(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/set-array'), require('@jridgewell/sourcemap-codec'), require('@jridgewell/trace-mapping')) :
    typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/set-array', '@jridgewell/sourcemap-codec', '@jridgewell/trace-mapping'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec, global.traceMapping));
})(this, (function (exports, setArray, sourcemapCodec, traceMapping) { 'use strict';

    const COLUMN = 0;
    const SOURCES_INDEX = 1;
    const SOURCE_LINE = 2;
    const SOURCE_COLUMN = 3;
    const NAMES_INDEX = 4;

    const NO_NAME = -1;
    /**
     * Provides the state to generate a sourcemap.
     */
    class GenMapping {
        constructor({ file, sourceRoot } = {}) {
            this._names = new setArray.SetArray();
            this._sources = new setArray.SetArray();
            this._sourcesContent = [];
            this._mappings = [];
            this.file = file;
            this.sourceRoot = sourceRoot;
            this._ignoreList = new setArray.SetArray();
        }
    }
    /**
     * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
     * with public access modifiers.
     */
    function cast(map) {
        return map;
    }
    function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    }
    function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
    }
    /**
     * Same as `addSegment`, but will only add the segment if it generates useful information in the
     * resulting map. This only works correctly if segments are added **in order**, meaning you should
     * not add a segment with a lower generated line/column than one that came before.
     */
    const maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    };
    /**
     * Same as `addMapping`, but will only add the mapping if it generates useful information in the
     * resulting map. This only works correctly if mappings are added **in order**, meaning you should
     * not add a mapping with a lower generated line/column than one that came before.
     */
    const maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
    };
    /**
     * Adds/removes the content of the source file to the source map.
     */
    function setSourceContent(map, source, content) {
        const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);
        const index = setArray.put(sources, source);
        sourcesContent[index] = content;
    }
    function setIgnore(map, source, ignore = true) {
        const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);
        const index = setArray.put(sources, source);
        if (index === sourcesContent.length)
            sourcesContent[index] = null;
        if (ignore)
            setArray.put(ignoreList, index);
        else
            setArray.remove(ignoreList, index);
    }
    /**
     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
     * a sourcemap, or to JSON.stringify.
     */
    function toDecodedMap(map) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList, } = cast(map);
        removeEmptyFinalLines(mappings);
        return {
            version: 3,
            file: map.file || undefined,
            names: names.array,
            sourceRoot: map.sourceRoot || undefined,
            sources: sources.array,
            sourcesContent,
            mappings,
            ignoreList: ignoreList.array,
        };
    }
    /**
     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
     * a sourcemap, or to JSON.stringify.
     */
    function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
    }
    /**
     * Constructs a new GenMapping, using the already present mappings of the input.
     */
    function fromMap(input) {
        const map = new traceMapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast(gen)._names, map.names);
        putAll(cast(gen)._sources, map.sources);
        cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast(gen)._mappings = traceMapping.decodedMappings(map);
        if (map.ignoreList)
            putAll(cast(gen)._ignoreList, map.ignoreList);
        return gen;
    }
    /**
     * Returns an array of high-level mapping objects for every recorded segment, which could then be
     * passed to the `source-map` library.
     */
    function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast(map);
        for (let i = 0; i < mappings.length; i++) {
            const line = mappings[i];
            for (let j = 0; j < line.length; j++) {
                const seg = line[j];
                const generated = { line: i + 1, column: seg[COLUMN] };
                let source = undefined;
                let original = undefined;
                let name = undefined;
                if (seg.length !== 1) {
                    source = sources.array[seg[SOURCES_INDEX]];
                    original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
                    if (seg.length === 5)
                        name = names.array[seg[NAMES_INDEX]];
                }
                out.push({ generated, source, original, name });
            }
        }
        return out;
    }
    // This split declaration is only so that terser can elminiate the static initialization block.
    function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = cast(map);
        const line = getLine(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source) {
            if (skipable && skipSourceless(line, index))
                return;
            return insert(line, index, [genColumn]);
        }
        const sourcesIndex = setArray.put(sources, source);
        const namesIndex = name ? setArray.put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
            sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
            return;
        }
        return insert(line, index, name
            ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]
            : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
    }
    function getLine(mappings, index) {
        for (let i = mappings.length; i <= index; i++) {
            mappings[i] = [];
        }
        return mappings[index];
    }
    function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
            const current = line[i];
            if (genColumn >= current[COLUMN])
                break;
        }
        return index;
    }
    function insert(array, index, value) {
        for (let i = array.length; i > index; i--) {
            array[i] = array[i - 1];
        }
        array[index] = value;
    }
    function removeEmptyFinalLines(mappings) {
 A^A\_ÃH-İ1 L5œİ1 H‰)L‰qè üÿÿAöÄtº    H‹Ïè‰A1 H‹l$XH‹ÇHƒÄ A^A\_ÃÌÌÌHƒééÿÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰t$WHƒì HÂİ1 H‹ÙH‰‹òH‹‰˜   ¿ÿÿÿÿ‹…Àt;Çt!‹ÇğÁƒøuH‹‹˜   º    DBèÿã‹1 H‹ƒ   ‹…Ét;ÏtğÁ8ƒÿuH‹‹   ÿ‹1 H‹Ëÿ›‰1 @öÆtºè   H‹ËèÄ@1 H‹t$8H‹ÃH‹\$0HƒÄ _ÃÌÌÌÌÌH‰\$H‰l$H‰t$WHƒì H‹yH‹é¹   H‹Úè@@1 H   H‹ğH‰Ç@    Æ@ H‹D‹AƒøvºÿÿÿA¸   è„  ëÿ\Š1 HMH‰0H‹H‹\$0H‹l$8H‹t$@HƒÄ _Hÿ`XÌÌÌÌÌÌÌÌÌÌE‹ÈL‹Âºÿÿÿÿé@  L‹Âºÿÿÿÿé  ÌÌÌD‹Âºÿÿÿÿé£  ÌÌÌD‹Âºÿÿÿÿéc	  ÌÌÌH‰\$H‰l$H‰t$H‰|$ AVHƒì0H‹yD‹ÂD‹ÚH‹éƒ¿Ü   –ÀE3öD¶ĞA‹ÖE‹ÊD‰T$ Aƒñ„ÀEDÆADÓè
ƒ  ANH‹Øè6?1 H   H‹ğH‰D‰pÆ@H‹D‹AƒøvºÿÿÿEFè  ëÿW‰1 HMH‰0H‹H‹\$@H‹l$HH‹t$PH‹|$XHƒÄ0A^Hÿ`XÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì8D‰L$ E‹ÈL‹ÂºÿÿÿÿèW	  HƒÄ8ÃÌÌ‹A‰H‹ÂÃÌÌÌÌÌÌÌH‰\$ ‰T$UVWATAUAVAWHƒì03ÿH©˜   ƒ¹Ü   L‹éH‹E ‹ßLc@M‹à†­   E…À  ‹÷D‹ÿ@ I‹   H‹U HcAHÆL‹tÁH‹JIÏ‹lI‹H‹ÿP@I‹L‹„Àt
‹T$xAÿPHëHT$pAÿP‹@I‹øH‹ÿP@I‹L‹„Àt
‹T$xAÿPHëH”$€   AÿP‹@ÅıØI­˜   HÿÆIƒÇ I;ôŒjÿÿÿéÛ   ‹D$xE3ÉÇD$(ÿÿÿÿ3ÒH‹Í‰D$ è   M…äµ   H‹÷L‹÷f„     I‹   H‹U HcAHÆL‹|ÁH‹JIÎ‹lI‹H‹ÿP@I‹L‹„Àt‹ÕAÿPHëHT$pAÿP‹@I‹•˜   ;øLøH‹JIÎ‹lI‹H‹ÿP@I‹L‹„Àt‹ÕAÿPHëH”$€   AÿP‹@;ØI­˜   LØHÿÆIƒÆ I;ôŒZÿÿÿ‹D$xA‰¨   H‹œ$ˆ   A‰…    A‰½¤   HƒÄ0A_A^A]A\_^]ÃÌÌÌÌÌÌÌÌÌH‹AH‹ˆ   ‹A+AÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì H‹H‹Ù‹ƒú†Ä   H‹º   ‹HáÿÿÿuDJúE3ÀJÿf‡1 H‰HƒÄ [Ã‹ E3ÉD‹ÁH‰|$0AI ÿF‡1 H‹H‹ø‹Q‰PL‹I‹IMcAIÁàJ	L+ÂLÁH‹HMÁHÈIƒààè>M1 H‹‹H3Oºñ3H‰OH‹‹…Àtƒøÿt ¸ÿÿÿÿğÁƒøuH‹º    DBèÿÅ†1 H‰;H‹|$0HƒÄ [ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$ ‰T$WHƒì H‹H‹ùIcèD‹ÅHcBHƒÂH4ÂHT$8ÿ½…1 H‹ØH‹LcHHHJÉH;ñt/HcT$8IÑLÕ   L+ÁLÀIÁøM…À~NÅ    H‹Öè_L1 L‹HMHcT$8IcAHÂLÖHÈIÉL;Ñt+IcALÅ   L+ÁMÁIÁøM…À~NÅ    I‹ÒèL1 ‹…Àtƒøÿt¸ÿÿÿÿğÁƒøu	H‹Ëÿÿ„1 H‹HcD$8H‹\$0HƒÀH‹l$@HcJH‹t$HHÁHÂHƒÄ _ÃÌÌÌH‹A‹€Ü   ÃÌÌÌÌÌH‰\$WHƒì H‹YøH‹úöƒØ   tH‹Ëèn  ‹ƒÔ   H‹\$0‰H‹ÇHƒÄ _ÃÌÌÌÌÌÌÌÌ@SHƒì H‹YøöƒØ   tH‹Ëè5  ¶ƒØ   $HƒÄ [ÃÌÌÌÌÌÌH‰\$H‰t$ WHƒì H‹‹úH‹YøH‹ñÿP@„Àu¸ÿÿÿÿH‹\$@H‹t$HHƒÄ _Ã‹ƒÌ   ƒÄ   H‰l$0+ø‹«È   L‰t$8D‹³Ğ   ;»    tH‹Nø‹×èáúÿÿ‹ƒ¤   H‹\$@ÅH‹l$0AÆL‹t$8H‹t$HHƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌ¶ÃÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$H‰|$ AVHƒì H‹YM‹ğ‹úH‹é…ÒyH‹ƒ   ‹x+x¹   è÷81 H‹ğH‹   L‰0Ç@    Æ@ H‹“   D‹‹×AƒøvA¸   è:ıÿÿëÿb~1 HMH‰0H‹H‹\$0H‹l$8H‹t$@H‹|$HHƒÄ A^Hÿ`XÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$WAVAWHƒì H‹y‹ÚH‹éI‹ĞH‹ÏE‹ùM‹ğèÃs  „À„€   I‹ÖH‹Íè q  „ÀtqHÇ   H‰t$@…Ûy	H‹‹X+X¹   è!81 H‹ğIV3ÀH‹ÏM…öHDĞD‰~H‰ˆFH‹D‹‹ÓAƒøvD@èeüÿÿëÿ}1 HMH‰0H‹ÿPXH‹t$@H‹\$HH‹l$PHƒÄ A_A^_ÃÌÌÌÌÌÌÌH‰\$H‰l$H‰t$H‰|$ AVHƒì H‹YM‹ğ‹úH‹é…ÒyH‹ƒ   ‹x+x¹   èw71 H‹ğH‹   L‰0Ç@    Æ@H‹“   D‹‹×AƒøvA¸   èºûÿÿëÿâ|1 HMH‰0H‹H‹\$0H‹l$8H‹t$@H‹|$HHƒÄ A^Hÿ`XÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$WAVAWHƒì0H‹iE‹Ğ‹úH‹ñ…ÒyH‹…   ‹x+xƒ½Ü   –ÀE3ÿ¶ÈE‹ÇD‹É‰L$ AƒñH‹Î„ÀEDÂED×A‹Òèhz  A