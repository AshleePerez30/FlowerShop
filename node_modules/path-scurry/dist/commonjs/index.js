"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;
const lru_cache_1 = require("lru-cache");
const path_1 = require("path");
const url_1 = require("url");
const actualFS = __importStar(require("fs"));
const fs_1 = require("fs");
const realpathSync = fs_1.realpathSync.native;
// TODO: test perf of fs/promises realpath vs realpathCB,
// since the promises one uses realpath.native
const promises_1 = require("fs/promises");
const minipass_1 = require("minipass");
const defaultFS = {
    lstatSync: fs_1.lstatSync,
    readdir: fs_1.readdir,
    readdirSync: fs_1.readdirSync,
    readlinkSync: fs_1.readlinkSync,
    realpathSync,
    promises: {
        lstat: promises_1.lstat,
        readdir: promises_1.readdir,
        readlink: promises_1.readlink,
        realpath: promises_1.realpath,
    },
};
// if they just gave us require('fs') then use our default
const fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS
    ? defaultFS
    : {
        ...defaultFS,
        ...fsOption,
        promises: {
            ...defaultFS.promises,
            ...(fsOption.promises || {}),
        },
    };
// turn something like //?/c:/ into c:\
const uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
const uncToDrive = (rootPath) => rootPath.replace(/\//g, '\\').replace(uncDriveRegexp, '$1\\');
// windows paths are separated by either / or \
const eitherSep = /[\\\/]/;
const UNKNOWN = 0; // may not even exist, for all we know
const IFIFO = 0b0001;
const IFCHR = 0b0010;
const IFDIR = 0b0100;
const IFBLK = 0b0110;
const IFREG = 0b1000;
const IFLNK = 0b1010;
const IFSOCK = 0b1100;
const IFMT = 0b1111;
// mask to unset low 4 bits
const IFMT_UNKNOWN = ~IFMT;
// set after successfully calling readdir() and getting entries.
const READDIR_CALLED = 0b0000_0001_0000;
// set after a successful lstat()
const LSTAT_CALLED = 0b0000_0010_0000;
// set if an entry (or one of its parents) is definitely not a dir
const ENOTDIR = 0b0000_0100_0000;
// set if an entry (or one of its parents) does not exist
// (can also be set on lstat errors like EACCES or ENAMETOOLONG)
const ENOENT = 0b0000_1000_0000;
// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK
// set if we fail to readlink
const ENOREADLINK = 0b0001_0000_0000;
// set if we know realpath() will fail
const ENOREALPATH = 0b0010_0000_0000;
const ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
const TYPEMASK = 0b0011_1111_1111;
const entToType = (s) => s.isFile()
    ? IFREG
    : s.isDirectory()
        ? IFDIR
        : s.isSymbolicLink()
            ? IFLNK
            : s.isCharacterDevice()
                ? IFCHR
                : s.isBlockDevice()
                    ? IFBLK
                    : s.isSocket()
                        ? IFSOCK
                        : s.isFIFO()
                            ? IFIFO
                            : UNKNOWN;
// normalize unicode path names
const normalizeCache = new Map();
const normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
        return c;
    const n = s.normalize('NFKD');
    normalizeCache.set(s, n);
    return n;
};
const normalizeNocaseCache = new Map();
const normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
        return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
};
/**
 * An LRUCache for storing resolved path strings or Path objects.
 * @internal
 */
class ResolveCache extends lru_cache_1.LRUCache {
    constructor() {
        super({ max: 256 });
    }
}
exports.ResolveCache = ResolveCache;
// In order to prevent blowing out the js heap by allocating hundreds of
// thousands of Path entries when walking extremely large trees, the "children"
// in this tree are represented by storing an array of Path entries in an
// LRUCache, indexed by the parent.  At any time, Path.children() may return an
// empty array, indicating that it doesn't know about any of its children, and
// thus has to rebuild that cache.  This is fine, it just means that we don't
// benefit as much from having the cached entries, but huge directory walks
// don't blow out the stack, and smaller ones are still as fast as possible.
//
//It does impose some complexity when building up the readdir data, because we
//need to pass a reference to the children array that we started with.
/**
 * an LRUCache for storing child entries.
 * @internal
 */
class ChildrenCache extends lru_cache_1.LRUCache {
    constructor(maxSize = 16 * 1024) {
        super({
            maxSize,
            // parent + children
            sizeCalculation: a => a.length + 1,
        });
    }
}
exports.ChildrenCache = ChildrenCache;
const setAsCwd = Symbol('PathScurry setAsCwd');
/**
 * Path objects are sort of like a super-powered
 * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}
 *
 * Each one represents a single filesystem entry on disk, which may or may not
 * exist. It includes methods for reading various types of information via
 * lstat, readlink, and readdir, and caches all information to the greatest
 * degree possible.
 *
 * Note that fs operations that would normally throw will instead return an
 * "empty" value. This is in order to prevent excessive overhead from error
 * stack traces.
 */
class PathBase {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
        return this.#dev;
    }
    #mode;
    get mode() {
        return this.#mode;
    }
    #nlink;
    get nlink() {
        return this.#nlink;
    }
    #uid;
    get uid() {
        return this.#uid;
    }
    #gid;
    get gid() {
        return this.#gid;
    }
    #rdev;
    get rdev() {
        return this.#rdev;
    }
    #blksize;
    get blksize() {
        return this.#blksize;
    }
    #ino;
    get ino() {
        return this.#ino;
    }
    #size;
    get size() {
        return this.#size;
    }
    #blocks;
    get blocks() {
        return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
        return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
        return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
        return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
        return this.#birthtimeMs;
    }
    #atime;
    get atime() {
        return this.#atime;
    }
    #mtime;
    get mtime() {
        return this.#mtime;
    }
    #ctime;
    get ctime() {
        return this.#ctime;
    }
    #birthtime;
    get birthtime() {
        return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */
    get path() {
        return (this.parent || this).fullpath();
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
            this.#fs = this.parent.#fs;
        }
        else {
            this.#fs = fsFromOption(opts.fs);
        }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
        if (this.#depth !== undefined)
            return this.#depth;
        if (!this.parent)
            return (this.#depth = 0);
        return (this.#depth = this.parent.depth() + 1);
    }
    /**
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path) {
        if (!path) {
            return this;
        }
        const rootPath = this.getRootString(path);
        const dir = path.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath
            ? this.getRoot(rootPath).#resolveParts(dirParts)
            : this.#resolveParts(dirParts);
        return result;
    }
    #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
            p = p.child(part);
        }
        return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
        const cached = this.#children.get(this);
        if (cached) {
            return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
  _A]_]Ã;øÿÀ‰…˜   ƒ½œ    uI‹Ïè“  I‹Ïè¥¬  ‹ÇHƒÄ(A_A]_]ÃÌÌÌÌÌÌÌÌ…Òx%H‹AL‹€   IcHA‹@+Á;Ğ}HcÂHÈI‹DÈÃ3ÀÃÌÌÌÌH‹IHƒy( tHÿ%>›0 H§û0 ÃÌÌÌÌÌÌH‰\$UVWHƒì H‹iø3ÛH‰H‹úH‹…   ‹H+HHcñ…É~N@ H‹   HcAHÃH‹LÁH‹ÿP`H…Àt$H‹ĞHL$@èEÆÿÿL‹ÀHT$HH‹Ïÿ–0 H‹H‰HÿÃH;Ş|¶H‹\$PH‹ÇHƒÄ _^]ÃÌÌÌÌÌÌH‰\$H‰l$H‰t$WHƒì I‹ñ‹úH‹éèÿÿ‹Ø…Àxs…ÿuƒø}(L‹ÎD‹À3ÒH‹ÍèpõÿÿƒëëSƒÿuƒû}	H‹Ç ÿÿÿÿƒëë;Gÿƒøv ƒÿtƒÿt&ƒÿt!ƒÿtƒÿtƒÿuëL‹ÎD‹Ã‹×H‹Íèõÿÿƒë‹ÃH‹\$0H‹l$8H‹t$@HƒÄ _ÃÌL‹ÊL‹ÑH…Òu3ÀÃL[ìJ I‹ÁM+ÁD  ¶B¶ +ÑuHÿÀ…Éuí…ÒuI‹ÂÃI‹ÑI‹ÊéºœÿÿÌÌÌÌÌÌÌÌÌÌH‰l$H‰t$ WATAVHƒì@L‹aI‹øHcòH‹é…ÒxJH‹   D‹HD+HA;ñ}6M…Àt1I‹ I‹ÈÿP`H…Àu9E3ÉHL$ E3À3Òÿ:š0 H‹ÈH û0 ÿ"š0 3ÀH‹l$pH‹t$xHƒÄ@A^A\_ÃH‹•   H   H‰\$`L‰|$hHcBHÆL‹|ÂèóVıÿL‹…   H‹\$`IcPHÖI‰|Ğ‹•˜   ;òuI‹Ìè   I‹ÇL‹|$hëÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‰T$H‰L$SUWHƒì`H‹AH‹éHcúH‰„$˜   Lc€˜   E…ÀxH‹   HcJIÈH‹LÊH‹ÿP`H‹Øë3Û…ÿˆ‘  H‹EH‹   HcJ‹B+Á;øu  HÏH‰t$XH‹LÊH‹ÿP`H‹ğH…À„Q  H;Ã„H  L‰d$PH‹ÍL‰l$HE2äL‰t$@L‰|$8è÷™ÿÿH‰D$ H‹øH…ÀttH‹H(‹QÁê
öÂu3ÒH‹ÈA´è.p H‹ÏE¶üè£ H‹Èèz  L‹ğH‹èH…Àt;H‹Èÿv–0 H‹øH…Àt,‹@…Àt%H…Ût ‹G3Ò…ÀH‹ËHEÕè_¥  „Àt	Aµë3í3ÿE2íH…Ût$H‹ËèÒ0  L‹´$˜   Aƒ¾œ    uH‹ËèÈ  ëL‹´$˜   D‹¼$ˆ   H‹ÎE‰¾˜   è‡ë  H‹ÎèŠ L‹t$ M…ö„Ç   E„í„¾   H‹ÎèÀ€  H…ÀtH‹ÈéŸ   H…ÿ„    ‹G…À„•   H‹İH…í„‰    H‹Ëè8¹  3ÉH‹Ø‹G…ÀHEÍH;ÙtNH‹Ëè-€  ¨tÙH‹Ëè1€  H…ÀuÌH‹ÖH‹Ëèq¥  „Àt½H‹C(ö@u³H‹ÓH‹ÎèX¤  „Àt¤º   H‹ËèW, ‹G3É…ÀHEÍH;ÙuH‹Îº   è:, L‹l$HE„äL‹d$Pt
²I‹Îè‘n H‹Œ$€   H„$ˆ   LL$ H‰D$(A¸   D‰¼$ˆ   Hrö0 HÇD$     ÿ+–0 L‹|$8L‹t$@H…ÿt¸ÿÿÿÿğÁƒøuH‹ÏèÂK0 H‹t$XHƒÄ`_][ÃÌH‰\$WHƒì@H‹H‹úH‹ÙÿPpƒøÿu1E3ÉHL$ E3À3ÒÿŠ–0 L‹ÇHˆ÷0 H‹Èÿo–0 H‹\$PHƒÄ@_Ã‹ĞH‹ËH‹\$PHƒÄ@_é°üÿÿº   éF+ ÌÌÌÌÌÌH‰l$WHƒì H‹yøH‹ê‹œ   …Étmƒùu]H‹‡   H‰t$8‹H+HHcñHƒş|=H‰\$03ÛH‹   HcAHÃH‹LÁH‹ÿP`H…ÀtH‹ÕH‹Èèe3 HÿÃH;Ş|ÏH‹\$0H‹t$8H‹l$@HƒÄ _ÃHc‡˜   …ÀxêH‹—   HcJHÈH‹LÊH‹ÿP`H…ÀtÌH‹ÕH‹ÈH‹l$@HƒÄ _é
3 ÌÌÌÌÌÌÌÌÌÌAVHƒì0L‹qA9–œ   „d  A‰–œ   I‹†   D‹@D+@„H  H‰\$@H‰t$PH‰|$XIcğ…Ò„¾   ƒú…  H‹Qfo¾Õ0 óD$ Hc‚˜   …Àx+H‹’   HcJHÈH‹LÊH‹ÿP`H…ÀtH‹@(@D$ H…öÅ   3Û€    I‹   HcAHÃH‹LÁH‹ÿP`H‹øH…Àt0‹L$ ÿÉ9L$(u‹L$$ÿÉ9L$,tHT$ H‹Ïè
2 H‹²H‹ÏÿPXHÿÃH;Ş|§ëaH‹AH‰l$H‹¨˜   …ítI3ÛE…À~B‹ûf„     I‹   HcAHÇH‹LÁH‹ÿP`H…ÀtL‹ ;İH‹È”ÂAÿPXÿÃHÿÇH;ş|ÉH‹l$HH‹t$PH‹\$@H‹|$XHƒÄ0A^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@UVAVAWHƒì8L‹qøE3ÿL‰:H‹òI‹†   ‹H+HHcé…É½   H‰\$0A‹ßH‰|$( I‹   HcAHÃH‹LÁH‹ÿP`H‹øH…ÀtvL‹ HT$pH‹ÈAÿP`HT$`H‹Ïè“‘ ‹T$p‹á   ù   H‹ÏAD×‰T$pHT$hèl‘ LD$pHT$x‹‹D$tá  ğ ù  Ğ H‹ÎADÇ‰D$tÿw0 H‹H‰HÿÃH;İŒ]ÿÿÿH‹|$(H‹\$0H‹ÆHƒÄ8A_A^^]ÃÌÌÌÌÌH‹A‹€œ   ÃÌÌÌÌÌH‰\$UVAVHƒì0H‹iH‹ñHcÚ…Òˆ  H‹…   D‹@D+@A;Ø  H   H‰|$Pè˜OıÿH‹•   HcJHËH‹|Ê‹ÓH   ÿ0 ‹…˜   ;Øu<Ç…˜   ÿÿÿÿH‹…   ‹H+H…É~;ÙSÿH‹ÎEÓè‘øÿÿëºÿÿÿÿH‹Îèòÿÿë
}ÿÈ‰…˜   HD$X‰\$XLL$ H‰D$(E3ÀHÇD$     Hpñ0 H‹Îÿ/‘0 H‹H‹ÏÿP`H…Àt.H‹H‹ÏÿP`H‹ÈÿÏ‹0 ‹H ÁéöÁuH‹H‹ÏÿR`H‹Èè;ˆ  H‹ÇH‹|$PH‹\$`HƒÄ0A^^]ÃH‹\$`3ÀHƒÄ0A^^]ÃÌÌÌÌÌ@SHƒì0D‰L$ H‹ÙM‹ÈL‹ÂH‹ÑHâğ0 ÿ¼0 H‹ÃHƒÄ0[ÃÌÌÌ…Òx+H‹AL‹€   IcHA‹@+Á;Ğ}HcÂHÈI‹LÈH‹Hÿ``3ÀÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‰T$Hƒì8HD$HHÇD$     LL$ H‰D$(E3ÀHfğ0 ÿ(0 HƒÄ8ÃÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰t$H‰|$AVHƒì I‹ğA‹ÙE3ÀL‹ñÿ0 INÿ½0 I‹NH\ù0 I‰D‹ÃH·ú0 H‹ÖI‰Fè  H‹\$0I‹ÆH‹t$8H‹|$@HƒÄ A^ÃÌÌH‰\$H‰t$H‰|$AVHƒì L‹ñA‹Ø¹¸  H‹òè E0 º H‹Èè[   H‹ĞE3ÀI‹Îÿô0 INÿò¼0 I‹NHÏø0 I‰D‹ÃH*ú0 H‹ÖI‰Fè~  H‹\$0I‹ÆH‹t$8H‹|$@HƒÄ A^ÃÌÌÌÌÌH‰\$H‰t$WHƒì@‹úH‹Ùÿ0 3öHõú0 H‰H‹¸   H‰sX‰³°   H‰s`H‰shH‰spH‰sxH‰³€   H‰³ˆ   H‰³   H‰³˜   H‰³    H‰³¨   ÿiÃ0 H‹À   ÿ\Ã0 H‹È   ÿ0 H‹Ø   ÇƒĞ   ÿÿÿÿÿğ0 H‹à   ÿã0 H‹è   ÿÖ0 H‹ğ   ÿÉ0 H‹H  H‰³ø   H‰³   H‰³  ‰³  H‰³  ‰³,  H‰³4  HÇƒ<  ÿÿÿÿÿZ·0 H‹X  ÿu”0 H‰³h  H‹€  HÇƒp  ÿÿÿÿÇƒx    U ÿ¬Œ0 H‰³ˆ  H‹¶‹0 H‰ƒ  H‹(†0 H‰ƒ˜  fÇƒ°  ·ƒ°    ‰ƒ°  ÿøŒ0 H…Àu6E3ÉHL$ E3À3Òÿ00 H‹ÈHfú0 ÿˆ0 H‹ÃH‹\$PH‹t$XHƒÄ@_Ã‹×H‹ËÿR†0 ƒK WÀH‹t$XH‹Ãƒ   H‹\$PHƒÄ@_ÃÌÌÌÌÌÌÌÌÌH‰\$WHƒì H‹H‹ùH…ÛtpH‰t$0H‹qH;ŞtH‹H…ÉtH‹º   ÿPHƒÃH;ŞuäH‹H‹WH‹t$0H+ÑHƒâøHú   rL‹AøHƒÂ'I+ÈHAøHƒøw I‹ÈèdB0 3ÀH‰H‰GH‰GH‹\$8HƒÄ _Ãÿ‚Ã0 ÌÌÌÌÌÌÌÌÌÌH‹ÄWHƒìpH‰XH‹ùH‰hğH‰pèL‰`àL‰hØL‰xÈHÎõ0 L‹H‰H(÷0 H‰O¹   A0     èşÿH‹èH…ÀtGI‹Ÿ˜  Hƒ{ Hst5H‹[ H;Şt,@ „          return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type) {
        return this[`is${type}`]();
    }
    getType() {
        return this.isUnknown()
            ? 'Unknown'
            : this.isDirectory()
                ? 'Directory'
                : this.isFile()
                    ? 'File'
                    : this.isSymbolicLink()
                        ? 'SymbolicLink'
                        : this.isFIFO()
                            ? 'FIFO'
                            : this.isCharacterDevice()
                                ? 'CharacterDevice'
                                : this.isBlockDevice()
                                    ? 'BlockDevice'
                                    : /* c8 ignore start */ this.isSocket()
                                        ? 'Socket'
                                        : 'Unknown';
        /* c8 ignore stop */
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
        return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
        return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
        return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
        return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
        return this.#type & LSTAT_CALLED ? this : undefined;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
        return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
        return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
        if (this.#linkTarget)
            return true;
        if (!this.parent)
            return false;
        // cases where it cannot possibly succeed
        const ifmt = this.#type & IFMT;
        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||
            this.#type & ENOREADLINK ||
            this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
        return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
        return !this.nocase
            ? this.#matchName === normalize(n)
            : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = await this.#fs.promises.readlink(this.fullpath());
            const linkTarget = (await this.parent.realpath())?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
            return target;
        }
        if (!this.canReadlink()) {
            return undefined;
        }
        /* c8 ignore start */
        // already covered by the canReadlink test, here for ts grumples
        if (!this.parent) {
            return undefined;
        }
        /* c8 ignore stop */
        try {
            const read = this.#fs.readlinkSync(this.fullpath());
            const linkTarget = (this.parent.realpathSync())?.resolve(read);
            if (linkTarget) {
                return (this.#linkTarget = linkTarget);
            }
        }
        catch (er) {
            this.#readlinkFail(er.code);
            return undefined;
        }
    }
    #readdirSuccess(children) {
        // succeeded, mark readdir called bit
        this.#type |= READDIR_CALLED;
        // mark all remaining provisional children as ENOENT
        for (let p = children.provisional; p < children.length; p++) {
            const c = children[p];
            if (c)
                c.#markENOENT();
        }
    }
    #markENOENT() {
        // mark as UNKNOWN and ENOENT
        if (this.#type & ENOENT)
            return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
        // all children are provisional and do not exist
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
            p.#markENOENT();
        }
    }
    #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
        // entry is not a directory, so any children                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 t` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
        if ((this.#type & ENOENT) === 0) {
            try {
                this.#applyStat(this.#fs.lstatSync(this.fullpath()));
                return this;
            }
            catch (er) {
                this.#lstatFail(er.code);
            }
        }
    }
    #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        // retain any other flags, but set the ifmt
        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
            this.#type |= ENOTDIR;
        }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach(cb => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
            if (allowZalgo)
                cb(null, []);
            else
                queueMicrotask(() => cb(null, []));
            return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
            const c = children.slice(0, children.provisional);
            if (allowZalgo)
                cb(null, c);
            else
                queueMicrotask(() => cb(null, c));
            return;
        }
        // don't have to worry about zalgo at this point.
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
            return;
        }
        this.#readdirCBInFlight = true;
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
            if (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            else {
                // if we didn't get an error, we always get entries.
                //@ts-ignore
                for (const e of entries) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            this.#callOnReaddirCB(children.slice(0, children.provisional));
            return;
        });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
            await this.#asyncReaddirInFlight;
        }
        else {
            /* c8 ignore start */
            let resolve = () => { };
            /* c8 ignore stop */
            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));
            try {
                for (const e of await this.#fs.promises.readdir(fullpath, {
                    withFileTypes: true,
                })) {
                    this.#readdirAddChild(e, children);
                }
                this.#readdirSuccess(children);
            }
            catch (er) {
                this.#readdirFail(er.code);
                children.provisional = 0;
            }
            this.#asyncReaddirInFlight = undefined;
            resolve();
        }
        return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
        if (!this.canReaddir()) {
            return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
            return children.slice(0, children.provisional);
        }
        // else read the directory, fill up children
        // de-provisionalize any provisional children.
        const fullpath = this.fullpath();
        try {
            for (const e of this.#fs.readdirSync(fullpath, {
                withFileTypes: true,
            })) {
                this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
        }
        catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
        }
        return children.slice(0, children.provisional);
    }
    canReaddir() {
        if (this.#type & ENOCHILD)
            return false;
        const ifmt = IFMT & this.#type;
        // we always set ENOTDIR when setting IFMT, so should be impossible
        /* c8 ignore start */
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
            return false;
        }
        /* c8 ignore stop */
        return true;
    }
    shouldWalk(dirs, walkFilter) {
        return ((this.#type & IFDIR) === IFDIR &&
            !(this.#type & ENOCHILD) &&
            !dirs.has(this) &&
            (!walkFilter || walkFilter(this)));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = await this.#fs.promises.realpath(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
        if (this.#realpath)
            return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
            return undefined;
        try {
            const rp = this.#fs.realpathSync(this.fullpath());
            return (this.#realpath = this.resolve(rp));
        }
        catch (_) {
            this.#markENOREALPATH();
        }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd) {
        if (oldCwd === this)
            return;
        const changed = new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
            changed.add(p);
            p.#relative = rp.join(this.sep);
            p.#relativePosix = rp.join('/');
            p = p.parent;
            rp.push('..');
        }
        // now un-memoize parents of old cwd
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
            p.#relative = undefined;
            p.#relativePosix = undefined;
            p = p.parent;
        }
    }
}
exports.PathBase = PathBase;
/**
 * Path class used on win32 systems
 *
 * Uses `'\\'` as the path separator for returned paths, either `'\\'` or `'/'`
 * as the path separator for parsing paths.
 */
class PathWin32 extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep = '\\';
    /**
     * Separator for parsing path strings.
     */
    splitSep = eitherSep;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return path_1.win32.parse(path).root;
    }
    /**
     * @internal
     */
    getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
            return this.root;
        }
        // ok, not that one, check if it matches another we know about
        for (const [compare, root] of Object.entries(this.roots)) {
            if (this.sameRoot(rootPath, compare)) {
                return (this.roots[rootPath] = root);
            }
        }
        // otherwise, have to create a new one.
        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);
    }
    /**
     * @internal
     */
    sameRoot(rootPath, compare = this.root.name) {
        // windows can (rarely) have case-sensitive filesystem, but
        // UNC and drive letters are always case-insensitive, and canonically
        // represented uppercase.
        rootPath = rootPath
            .toUpperCase()
            .replace(/\//g, '\\')
            .replace(uncDriveRegexp, '$1\\');
        return rootPath === compare;
    }
}
exports.PathWin32 = PathWin32;
/**
 * Path class used on all posix systems.
 *
 * Uses `'/'` as the path separator.
 */
class PathPosix extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep = '/';
    /**
     * separator for generating path strings
     */
    sep = '/';
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    getRootString(path) {
        return path.startsWith('/') ? '/' : '';
    }
    /**
     * @internal
     */
    getRoot(_rootPath) {
        return this.root;
    }
    /**
     * @internal
     */
    newChild(name, type = UNKNOWN, opts = {}) {
        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
}
exports.PathPosix = PathPosix;
/**
 * The base class for all PathScurry classes, providing the interface for path
 * resolution and filesystem operations.
 *
 * Typically, you should *not* instantiate this class directly, but rather one
 * of the platform-specific classes, or the exported {@link PathScurry} which
 * defaults to the current platform.
 */
class PathScurryBase {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots;
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {
        this.#fs = fsFromOption(fs);
        if (cwd instanceof URL || cwd.startsWith('file://')) {
            cwd = (0, url_1.fileURLToPath)(cwd);
        }
        // resolve and split root, and then add to the store.
        // this is the only time we call path.resolve()
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        // resolve('/') leaves '', splits to [''], we don't want that.
        if (split.length === 1 && !split[0]) {
            split.pop();
        }
        /* c8 ignore start */
        if (nocase === undefined) {
            throw new TypeError('must provide nocase setting to PathScurryBase ctor');
        }
        /* c8 ignore stop */
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
            const l = len--;
            prev = prev.child(part, {
                relative: new Array(l).fill('..').join(joinSep),
                relativePosix: new Array(l).fill('..').join('/'),
                fullpath: (abs += (sawFirst ? '' : joinSep) + part),
            });
            sawFirst = true;
        }
        this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path = this.cwd) {
        if (typeof path === 'string') {
            path = this.cwd.resolve(path);
        }
        return path.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
        return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
        // first figure out the minimum number of paths we have to tesèËÓÿÿH‹ĞI‹ÏèLÖÿÿ„ÀuL‹D$XIƒÀ I‹ÖH‹Ïèôÿÿ„Àt<L‹Œ$°   I‹AH‰t$(H‹ÓH‹Ï€x tE3Àè  H‹Ãë0L‹L$XA°è  H‹ÃëH‰t$ M‹ÎHT$@H‹Ïè³  H‹H‰H‹ÃH‹L$`H3Ìè½2 HƒÄpA_A^_^[ÃÌ@SHƒì H‹ÚèîĞÿÿH‹ÈH‹ÓHƒÄ [é®ëÿÿÌÌH‰\$WHƒì H‹ÙèÊĞÿÿ¹H   è¨2 H‹ËH‹øèµĞÿÿH‹ÏH‹Øè†ãÿÿH‹H‰HOèwãÿÿH‹H‰HOèhãÿÿH‹H‰H‹\$0H‹ÇHƒÄ _ÃH‰\$WHƒì H‹úèfĞÿÿHO H‹Øè6ãÿÿH‹ĞH‹Ëè{ëÿÿH‹×H‹ËH‹\$0HƒÄ _é
ëÿÿÌÌH‹ÄH‰XH‰hH‰pH‰x AVHƒì I‹ÙAŠèL‹òH‹ñèĞÿÿH‹øH¹ã8ã8H‹@H;ÁrH‹T$XH‹ÎèsÿÿÿHˆ; ÿ"Å ÌH‹t$XHÿÀH‰GH‹ÏH‰^H;uè İÿÿH‹ÏH‰0èéÔÿÿH‰0ë*@„ítH‰3è×ÔÿÿH;u#H‹ÏèÊÔÿÿëH‰sè×ÜÿÿH;uH‹ÏèÊÜÿÿH‰0H‹FH‹Şé³   H‹CH‹PH‹
H;ÁuDH‹J€y t@H;XuH‹ĞH‹ÏH‹ØèİŞÿÿH‹CÆ@H‹CH‹HÆA H‹ÏH‹SH‹Rèáİÿÿë[€y uÆ@ÆAH‹CH‹HÆA H‹CH‹Xë7H;uH‹ĞH‹ÏH‹Øè¨İÿÿH‹CÆ@H‹CH‹HÆA H‹ÏH‹SH‹Rè\ŞÿÿH‹C€x „CÿÿÿH‹Ïè
ÜÿÿH‹ÆAH‹ÏèwáÿÿL‹ÀH‹ÖI‹Îè…ÓÿÿH‹\$0I‹ÆH‹l$8H‹t$@H‹|$HHƒÄ A^ÃÌÌÌ@SVWATAUAVAWHƒìpHÇD$XşÿÿÿH‹À€ H3ÄH‰D$hL‰L$8H‹ÚL‹ñH‰L$PL‹¬$Ğ   L‰l$Hè"ÎÿÿL‹àL‹8I‹@¶€ u&L‹ÿLG H‹T$8I‹Îè“ğÿÿ@Šğ„ÀtH‹?ëÚH‹ëÔ3ÿH‰|$`I‹Ìè¶àÿÿL‹ÀI‹×HL$`èÂÒÿÿ@„ö„«   HT$@I‹ÎèTĞÿÿH‹ĞHL$`ègÒÿÿ„Àt:ÆD$0L‰l$(M‹ÏA°HT$@I‹ÎèNıÿÿH‹H‰HL$0èRàÿÿŠˆKH‹Ãéê   H‹D$`@8xtH‹@H‰D$`ëBH‹@8yt-H‹HëH;uH‹ÁH‰L$`H‹I@8yté@8xuH‹ÁH‰L$`ëèˆİÿÿë¼H‹D$`HP L‹D$8I‹Îè˜ïÿÿI‹Î„Àt4ÆD$0L‰l$(M‹ÏDŠÆHT$@è§üÿÿH‹ H‰HL$0è«ßÿÿŠˆKH‹ÃëFèÀÌÿÿH‹øIM èßÿÿH‹ĞH‹ÏèÕçÿÿI‹ÕH‹ÏènçÿÿÆD$0 H‹D$`H‰HL$0ècßÿÿŠˆKH‹ÃH‹L$hH3Ìè&. HƒÄpA_A^A]A\_^[ÃÌÌHè ÃH‹ÄH‰XH‰hH‰pH‰x AVIƒÎÿH‹úM‹Î3íIÿÁfB9,JuöHƒyH‹ÑrH‹H‹AL;È‡…   I+ÁL;Àw}M…Ét{HpH4rNBH‹ÆI+ÀHÑøt·fA9tIƒÀHƒèuğL‹ÅM…ÀtFM‹ÑH‹ÇM…ÉtI‹ÈH+ÏD··fD;ÛuHƒÀIƒêuè‹Å…ÀtIƒÀë¥ÀƒàşÿÀëíL+ÂIÑøëM‹ÆH‹\$I‹ÀH‹l$H‹t$ H‹|$(A^ÃÌ@SHƒì Š0ç öØHÉ3ÛH#òæ t$Šç öØSHÉH#Ûæ H‹H‹@(ÿÆÄ ëŠÃ„Àu9µ u¹   è<ÿşÿ„Àt³ŠÃHƒÄ [ÃÌÌH‹ÄUHh¡Hì   HÇEçşÿÿÿH‰XH‰pH‰xH‹ÚH‹ùfo[ö óEÿ3öf‰uïDFJH•7 HMïè€ÛşÿHUïH‹Ïèë×şÿHMïèeØşÿfoö óEf‰uDFH)8 HMèDÛşÿH‹ÓHMèÓÿÿWÀóEÿ EïHMÿH‰p^H‰Xf‰0H7 HMïèÿÿ E/HM?H‰pH‰Xf‰0HU/H‹ÏèT×şÿHM/èÎ×şÿHMïèÄ×şÿHMèº×şÿ‹G HƒÀ¹ÿÿÿÿH;Áw‰G Lœ$   I‹[I‹sI‹{ I‹ã]Ãè|>şÿÌÌÌÌH‹ÄUHh¡Hìğ   HÇEçşÿÿÿH‰XH‰pH‰xL‰p H‹ÚH‹ñHU/èN  H‹øfoõ óE—E3öfD‰u‡EFHÓ7 HM‡è&ÚşÿH‹ÓHM‡èµÿÿWÀóE× EÇHM×L‰pA^H‰XfD‰0H6 HMÇè~ÿÿWÀóE· E§HM·L‰pH‰XfD‰0L‹ÇHU§HMè#_ÿÿH£5 H‹Èè;ÿÿ EïHMÿL‰pH‰XfD‰0HUïH‹ÎèğÕşÿHMïèjÖşÿHMè`ÖşÿHM§èVÖşÿHMÇèLÖşÿHM‡èBÖşÿHM/è8Öşÿfoğó óE—fD‰u‡EFJH+6 HM‡èÙşÿHU‡H‹ÎèÕşÿHM‡èûÕşÿLœ$ğ   I‹[I‹sI‹{ M‹s(I‹ã]ÃÌÌH‰\$WHƒì 3ÛH‹ù9Y vH‘6 H‹ÏèYÿÿÿÃ9_ wêH‹\$8HƒÄ _ÃÌÌÌH‹ÄWHƒìpHÇ@¨şÿÿÿH‰XH‰pH‹ÚH‹ùè¥ÿÿÿfo9ó óD$83öf‰t$(IƒÈÿIÿÀfB94CuöH‹ÓHL$(èUØşÿH%á HL$(èßÿÿ D$HHL$XH‰pHÇ@   f‰0HT$HH‹ÏèÔşÿHL$HèÕşÿHL$(èüÔşÿL\$pI‹[I‹sI‹ã_ÃÌÌ@SHƒìPHÇD$ şÿÿÿH‹ÙHT$(èP  HƒxrH‹ L‹ÀHÿ5 H‹Ëè3  HL$(è¤ÔşÿHƒÄP[ÃÌÌH‹ÄWHìà   HÇD$@şÿÿÿH‰X H‹-y H3ÄH‰„$Ğ   H‹úH‹ÙM‹ÈL¢8 º@   HL$Pè§ÿşÿfoò óD$03Àf‰D$ HL$PIƒÈÿIÿÀfB9AuöHT$PHL$ è ×şÿLD$ Hƒ|$8LCD$ H‹×H‹Ëèƒ   HL$ èôÓşÿH‹Œ$Ğ   H3ÌèÔ' H‹œ$  HÄà   _ÃÌÌÌ@WHƒìPHÇD$ şÿÿÿH‰\$`H‹ÚH‹ùHT$(è
  HƒxrH‹ L‹ÀH‹ÓH‹Ïè   HL$(èˆÓşÿH‹\$`HƒÄP_ÃÌH‹ÄUHh¡HìĞ   HÇEşÿÿÿH‰XH‰pH‰xL‰p I‹ØH‹òH‹ùèkıÿÿE3öH…ÛuHU§èb	  ë-foìğ óE·fD‰u§IƒÈÿIÿÀfF94CuöH‹ÓHM§èÖşÿfo¿ğ óE÷fD‰uçA¸   H°3 HMçèãÕşÿH‹ÖHMçèrÿÿWÀóE× EÇHM×L‰p»   H‰XfD‰0LE§HUÇHM/è[ÿÿH‘1 H‹Èè)ÿÿ EHML‰pH‰XfD‰0HUH‹ÏèŞÑşÿHMèXÒşÿHM/èNÒşÿHMÇèDÒşÿHMçè:ÒşÿHM§è0ÒşÿLœ$Ğ   I‹[I‹sI‹{ M‹s(I‹ã]ÃÌÌÌH‹ÄWHƒìpHÇ@¨şÿÿÿH‰X‹ÚH‹ùèüÿÿD‹ÃHT$Hèå  Hİ0 H‹Èèuÿÿ D$(HL$83ÉH‰HHÇ@   f‰HT$(H‹Ïè"ÑşÿHL$(è›ÑşÿHL$HèÑşÿH‹œ$€   HƒÄp_ÃÌÌH‹ÄWHì   HÇ@ˆşÿÿÿH‰XH‰pH‹ÚH‹ùè~ûÿÿL‹ÃHT$hè±  A¹   L2 H‹ÈèïaÿÿWÀóD$8 D$(HL$83öH‰p^H‰Xf‰0H0 HL$(èœÿÿ D$HHL$XH‰pH‰Xf‰0HT$HH‹ÏèOĞşÿHL$HèÈĞşÿHL$(è½ĞşÿHL$hè²ĞşÿLœ$   I‹[I‹sI‹ã_ÃÌH‹ÄWHƒìpHÇ@¨şÿÿÿH‰XH‰pH‹ÚH‹ùèúÿÿ3öH…ÛuHT$(è”  ë/foî óD$8f‰t$(IƒÈÿIÿÀfB94CuöH‹ÓHL$(è<ÓşÿH0/ HL$(èÆÿÿ D$HHL$XH‰pHÇ@   f‰0HT$HH‹ÏèuÏşÿHL$HèîÏşÿHL$(èãÏşÿL\$pI‹[I‹sI‹ã_ÃÌH‹ÄWHƒìPHÇ@ÈşÿÿÿH‰XH‰hH‰pH‹úH‹Ù3íH…ÒuèZ  H‹\$`H‹l$hH‹t$pHƒÄP_Ãè¬ùÿÿH0 H‹Ëèÿÿ‹C HƒÀ¾ÿÿÿÿH;Æ‡  ‰C D‹H‹ËènúÿÿL‹GHs0 H‹ËèsûÿÿD‹GHT$(è5  HƒxrH‹ L‹ÀH¨0 H‹ËèœûÿÿHL$(èÏşÿL‹GHj0 H‹Ëè*ûÿÿH‹Ëèùÿÿfoªì óD$8f‰l$(A¸   H²0 HL$(èÌÑşÿHT$(H‹Ëè6ÎşÿHL$(è¯Îşÿ‹C HƒÀH;ÆwJ‰C H‹W H‹ËèT   ‹C HƒèH;ÆwA‰C ƒ?0rL‹G(H0 H‹Ëèñúÿÿ‹C HƒèH;Æw‰C é·şÿÿèH5şÿÌèB5şÿÌè<5şÿÌè65şÿÌÌH‹ÄWHì   HÇ@ˆşÿÿÿH‰XH‰hH‰pH‹ÚH‹ù3öH…ÒuèÇ  Lœ$   I‹[I‹kI‹s I‹ã_ÃèøÿÿH*0 H‹Ïè‚	ÿÿ‹G HƒÀ½ÿÿÿÿH;Å‡X  ‰G D‹A‹Àƒè„  ƒè„È   ƒø„   HT$hè#  H‹ØfoTë óD$8f‰t$(A¸   Hä0 HL$(èvĞşÿL‹ÃHT$(HL$Hè×UÿÿHƒxrH‹ L‹ÀHÒ/ H‹ÏèÆùÿÿHL$Hè7ÍşÿHL$(è,ÍşÿHL$hè!Íşÿé   LE0 H–/ H‹ÏèŠùÿÿL‹CHc/ H‹Ïè#ùÿÿH0 ëOL³/ Hd/ H‹ÏèXùÿÿL‹CH1/ H‹ÏèñøÿÿHb/ ëL¹. H2/ H‹Ïè&ùÿÿH/ L‹CH‹Ïè¿øÿÿ‹G HƒèH;Åw‰G élşÿÿèj3şÿÌèd3şÿÌÌÌÌH‰\$H‰t$WHƒì H‹úH‹ÙH…Òuè  H‹\$0H‹t$8HƒÄ _Ãè\öÿÿHÉ/ H‹ËèÉÿÿ‹C ¾ÿÿÿÿHƒÀH;Æw9‰C Hö/ L‹H‹Ëèg÷ÿÿL‹GH¸/ H‹ËèT÷ÿÿ‹C HƒèH;Æw‰C ë’èÎ2şÿÌÌH‹ÄWHƒìpHÇ@¨şÿÿÿH‰XH‹ÚH‹ùèİõÿÿL‹ÃHT$Hè  H¤* H‹Èè<ÿÿ D$(HL$83ÉH‰HHÇ@   f‰HT$(H‹ÏèéÊşÿHL$(èbËşÿHL$HèWËşÿH‹œ$€   HƒÄp_ÃÌ@SHƒìpHÇD$ şÿÿÿH‹ÙèUõÿÿHT$HèS  H* H‹Èè·ÿÿ D$(HL$83ÉH‰HHÇ@   f‰HT$(H‹ËèdÊşÿHL$(èİÊşÿHL$HèÒÊşÿHƒÄp[ÃH‹ÄUHh¡Hì   HÇE—şÿÿÿH‰XH‰x H‹Vo H3ÄH‰EGH‹ÚH‹ùè¸ôÿÿL‹ËL¢. º@   HMÇèĞõşÿfo4è óE‡3Ûf‰\$ HEÇIƒÈÿIÿÀfB9@uöHUÇHL$ èLÍşÿH@) HL$ èÖÿÿ EŸHM¯H‰XHÇ@   f‰HUŸH‹ÏèˆÉşÿHMŸèÊşÿHL$ è÷ÉşÿH‹MGH3ÌèÛ Lœ$   I‹[ I‹{(I‹ã]ÃÌÌ@SHƒì 3ÀHÇB   H‹ÚH‰Bf‰H‹ËHÈ× D@è«ÌşÿH‹ÃHƒÄ [ÃÌÌH‰\$WHì€   H‹8n H3ÄH‰D$p3ÿH‰T$ H‹ÚM…Àuè˜ÿÿÿëHM‹ÈHL$0Lg- º    è¥ôşÿH‰{HD$0HÇC   IƒÈÿf‰;IÿÀfB9<@uöHT$0H‹Ëè&ÌşÿH‹ÃH‹L$pH3Ìè H‹œ$   HÄ€   _ÃÌ@SHì€   H‹ m H3ÄH‰D$pH‹ÚH‰T$ E‹ÈHL$0L- º    èôşÿ3ÀHÇC   H‰CHL$0f‰IƒÈÿIÿÀfB9AuöHT$0H‹ËèšËşÿH‹ÃH‹L$pH3Ìèv HÄ€   [ÃÌ@SHì€   H‹m H3ÄH‰D$pH‹ÚH‰T$ E‹ÈHL$0L™, º    è—óşÿ3ÀHÇC   H‰CHL$0f‰IƒÈÿIÿÀfB9AuöHT$0H‹ËèËşÿH‹ÃH‹L$pH3Ìèò HÄ€   [ÃÌH‰\$WHƒì H‹ùèî+ÿÿH‹ĞH‹Ïè{ÿÿèR  H‹ØH…ÀtPH‹H‹ÈH‹B0ÿ³ Hƒx t9Hp, H‹ÏèHÿÿH‹H‹ËH‹@0ÿh³ H‹ĞH‹Ïè	ÇşÿHæ+ H‹ÏèÿÿH‹\$0HƒÄ _ÃÌÌÌ@SHƒì@HƒyH‹ÙH‹ÁrH‹H‰D$0Ln, H_û A¹Ó  H‰D$(H, H¾À ¹   H‰D$ èÇòşÿ3ÉH‹ÃHƒ{H‰KrH‹f‰‰K HƒÄ@[Ãé[  ÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì H?, H‹ùH‰‹ÚHÁ   èËÆşÿHOpèÂÆşÿHOPè¹ÆşÿHO0è°ÆşÿHOè§ÆşÿöÃtºÈ   H‹Ïè± H‹\$0H‹ÇHƒÄ _ÃÌÌÌL‹ÜWHƒì0IÇCèşÿÿÿI‰[I‰s ŠVÒ 3ÿ„À…Û   H5uÒ I‰sH‹Îÿ(¬ Š1Ò „À…¯   ¹È   èS H‰D$HHƒ+ H‰_‰XH‰x OH‰H(f‰xH‰x@H‰HHf‰x0H‰x`H‰Hhf‰xPH‰¸€   H‰ˆˆ   f‰xpH‰¸    H‰ˆ¨   f‰¸   Ç€°      @ˆ¸´   H‰¸µ   H‰¸½   f‰¸Å   @ˆ¸Ç   H‹ĞHÄ è,  †zÑ H‹ÎÿA« HÄ H‹\$PH‹t$XHƒÄ0_éÖ¼ÿÿÌÌÌÌÌÌH‰L$Hƒì(¶ZÓ …Àt3Éè­ñşÿH‹D$0‹@HƒÄ(ÃÌÌÌÌÌÌÌÌH‰L$Hƒì(¶)Ó …Àt3Éè}ñşÿH‹D$0Š€´   HƒÄ(ÃÌÌÌÌÌH‰L$H‹D$H   ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰L$H‹D$Š€°   ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰L$H‹D$HƒÀPÃÌH‰L$H‹D$HƒÀpÃÌH‰L$H‹D$Š€±   ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‰T$H‰L$HcD$H‹L$Š„µ   ÃÌH‰T$H‰L$Hì  H‹Œ$  è®   H‹„$  H‹Œ$  H‰H‹„$  Hƒ8 t
ÇD$0   ëÇD$0    ¶D$0…Àu7ÇD$ W €L_Ï A¸F   H® HL$@è#şÿH1 HL$@è* HÄ  ÃÌÌÌH‰L$Hƒì(H‹L$0è   HƒÄ(ÃH‰L$H‹D$HÇ     H‹D$ÃÌH‰L$HƒìHH‹D$PH‹ H‰D$(H‹D$(H‰D$ Hƒ|$  t-H‹D$ H‹ H‹@@H‰D$0º   H‹L$ H‹D$0ÿ¯ H‰D$8ë	HÇD$8    H‹D$PHÇ     HƒÄHÃÌHƒa HÄ( H‰AHQ) H‰H‹ÁÃÌÌHƒì8HÇD$ şÿÿÿH‹IH…Ét+H‹H‹@ÿµ® L‹ÀH…ÀtH‹H‹º   I‹Èÿ˜® HƒÄ8ÃÌÌ@SHìP  H‹`g H3ÄH‰„$@  H‹ÙH…Éu2Àëw3ÒHL$0A¸  è¯( H‹ÓHL$0èæ   H‹D$0HcHHÊ( ‹\@H‰D0H‹D$0HcHH‹Á‘Pÿÿÿ‰T,HL$@è  HL$Hÿ&ª HŒ$à   ÿ « öÃ”ÀH‹Œ$@  H3Ìè HÄP  [ÃÌ@SHì€   H‹¨f H3ÄH‰D$p3ÒH‹ÙHL$ DBPè( H‹HT$ A¸   H‹ËH‹@Hÿ’­ …ÀxH|$0   @¹ß €GÁH‹L$pH3Ìè HÄ€   [ÃÌÌÌH‹ÄD‰H H‰HWHƒì@HÇ@ØşÿÿÿH‰XH‰pH‹òH‹ùƒ`  H³' H‰HÁ°   ÿKª ÇD$h   H_E3ÉE3ÀH‹ÓH‹Ïÿ<© H‹HcHH…' H‰9H‹HcH‘Pÿÿÿ‰T9üH‰\$(H‹Ëÿª Hº& H‰E3À3ÒH‹Ëè~  Hƒ»€    …   º   DB?H‹Îÿ	© H…À„ƒ   A¸   H‹ĞH‹ËèC  HT$(H‹ËÿÑ¨ H‹Èèä  H‹ğH‹Èÿt¨ „ÀtHƒch ëH‰shH‹Ëÿœ¨ H‹L$0H…Ét*H‹H‹@ÿ,¬ L‹ÀH…ÀtH‹H‹º   I‹Èÿ¬ ë3ÛH…ÛuH‹HcHHÏE3ÀSÿ © H‹ÇH‹\$XH‹t$`HƒÄ@_ÃÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì H‹ÙH‹Êè7  H‹ÈH‹øÿÇ§ „ÀtHƒch ëH‹ËH‰{hÿï§ H‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì Hƒ¹€    H‹Ùt'H‹ƒÏÿ‹×H‹@ÿW« ;ÇtH‹‹€   ÿæª …Àx3ÿH‹\$0‹ÇHƒÄ _ÃÌÌÌ => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
                    }
                    else {
                        if (e.shouldWalk(dirs, walkFilter)) {
                            walk(e, next);
                        }
                        else {
                            next();
                        }
                    }
                }
            }, true); // zalgooooooo
        };
        const start = entry;
        return new Promise((res, rej) => {
            walk(start, er => {
                /* c8 ignore start */
                if (er)
                    return rej(er);
                /* c8 ignore stop */
                res(results);
            });
        });
    }
    walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = [];
        if (!filter || filter(entry)) {
            results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    results.push(withFileTypes ? e : e.fullpath());
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
        return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
        // iterating async over the stream is significantly more performant,
        // especially in the warm-cache scenario, because it buffers up directory
        // entries in the background instead of waiting for a yield for each one.
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            options = entry;
            entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
        return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        if (!filter || filter(entry)) {
            yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = new Set([entry]);
        for (const dir of dirs) {
            const entries = dir.readdirSync();
            for (const e of entries) {
                if (!filter || filter(e)) {
                    yield withFileTypes ? e : e.fullpath();
                }
                let r = e;
                if (e.isSymbolicLink()) {
                    if (!(follow && (r = e.realpathSync())))
                        continue;
                    if (r.isUnknown())
                        r.lstatSync();
                }
                if (r.shouldWalk(dirs, walkFilter)) {
                    dirs.add(r);
                }
            }
        }
    }
    stream(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = new Set();
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const onReaddir = (er, entries, didRealpaths = false) => {
                    /* c8 ignore start */
                    if (er)
                        return results.emit('error', er);
                    /* c8 ignore stop */
                    if (follow && !didRealpaths) {
                        const promises = [];
                        for (const e of entries) {
                            if (e.isSymbolicLink()) {
                                promises.push(e
                                    .realpath()
                                    .then((r) => r?.isUnknown() ? r.lstat() : r));
                            }
                        }
                        if (promises.length) {
                            Promise.all(promises).then(() => onReaddir(null, entries, true));
                            return;
                        }
                    }
                    for (const e of entries) {
                        if (e && (!filter || filter(e))) {
                            if (!results.write(withFileTypes ? e : e.fullpath())) {
                                paused = true;
                            }
                        }
                    }
                    processing--;
                    for (const e of entries) {
                        const r = e.realpathCached() || e;
                        if (r.shouldWalk(dirs, walkFilter)) {
                            queue.push(r);
                        }
                    }
                    if (paused && !results.flowing) {
                        results.once('drain', process);
                    }
                    else if (!sync) {
                        process();
                    }
                };
                // zalgo containment
                let sync = true;
                dir.readdirCB(onReaddir, true);
                sync = false;
            }
        };
        process();
        return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === 'string') {
            entry = this.cwd.resolve(entry);
        }
        else if (!(entry instanceof PathBase)) {
            opts = entry;
            entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        const dirs = new Set();
        if (!filter || filter(entry)) {
            results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process = () => {
            let paused = false;
            while (!paused) {
                const dir = queue.shift();
                if (!dir) {
                    if (processing === 0)
                        results.end();
                    return;
                }
                processing++;
                dirs.add(dir);
                const entries = dir.readdirSync();
                for (const e of entries) {
                    if (!filter || filter(e)) {
                        if (!results.write(withFileTypes ? e : e.fullpath())) {
                            paused = true;
                        }
                    }
                }
                processing--;
                for (const e of entries) {
                    let r = e;
                    if (e.isSymbolicLink()) {
                        if (!(follow && (r = e.realpathSync())))
                            continue;
                        if (r.isUnknown())
                            r.lstatSync();
                    }
                    if (r.shouldWalk(dirs, walkFilter)) {
                        queue.push(r);
                    }
                }
            }
            if (paused && !results.flowing)
                results.once('drain', process);
        };
        process();
        return results;
    }
    chdir(path = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;
        this.cwd[setAsCwd](oldCwd);
    }
}
exports.PathScurryBase = PathScurryBase;
/**
 * Windows implementation of {@link PathScurryBase}
 *
 * Defaults to case insensitve, uses `'\\'` to generate path strings.  Uses
 * {@link PathWin32} for Path objects.
 */
class PathScurryWin32 extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '\\';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, path_1.win32, '\\', { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
            p.nocase = this.nocase;
        }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
        // if the path starts with a single separator, it's not a UNC, and we'll
        // just get separator as the root, and driveFromUNC will return \
        // In that case, mount \ on the root from the cwd.
        return path_1.win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return (p.startsWith('/') || p.startsWith('\\') || /^[a-z]:(\/|\\)/i.test(p));
    }
}
exports.PathScurryWin32 = PathScurryWin32;
/**
 * {@link PathScurryBase} implementation for all posix systems other than Darwin.
 *
 * Defaults to case-sensitive matching, uses `'/'` to generate path strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryPosix extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = '/';
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, path_1.posix, '/', { ...opts, nocase });
        this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
        return '/';
    }
    /**
     * @internal
     */
    newRoot(fs) {
        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
        return p.startsWith('/');
    }
}
exports.PathScurryPosix = PathScurryPosix;
/**
 * {@link PathScurryBase} implementation for Darwin (macOS) systems.
 *
 * Defaults to case-insensitive matching, uses `'/'` for generating path
 * strings.
 *
 * Uses {@link PathPosix} for Path objects.
 */
class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
    }
}
exports.PathScurryDarwin = PathScurryDarwin;
/**
 * Default {@link PathBase} implementation for the current platform.
 *
 * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.
 */
exports.Path = process.platform === 'win32' ? PathWin32 : PathPosix;
/**
 * Default {@link PathScurryBase} implementation for the current platform.
 *
 * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on
 * Darwin (macOS) systems, {@link PathScurryPosix} on all others.
 */
exports.PathScurry = process.platform === 'win32'
    ? PathScurryWin32
    : process.platform === 'darwin'
        ? PathScurryDarwin
        : PathScurryPosix;
//# sourceMappingURL=index.js.map