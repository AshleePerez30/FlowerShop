"use strict";
// synchronous utility for filtering entries and calculating subwalks
Object.defineProperty(exports, "__esModule", { value: true });
exports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;
const minimatch_1 = require("minimatch");
/**
 * A cache of which patterns have been processed for a given Path
 */
class HasWalkedCache {
    store;
    constructor(store = new Map()) {
        this.store = store;
    }
    copy() {
        return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
            cached.add(pattern.globString());
        else
            this.store.set(fullpath, new Set([pattern.globString()]));
    }
}
exports.HasWalkedCache = HasWalkedCache;
/**
 * A record of which paths have been matched in a given walk step,
 * and whether they only are considered a match if they are a directory,
 * and whether their absolute or relative path should be returned.
 */
class MatchRecord {
    store = new Map();
    add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === undefined ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
        return [...this.store.entries()].map(([path, n]) => [
            path,
            !!(n & 2),
            !!(n & 1),
        ]);
    }
}
exports.MatchRecord = MatchRecord;
/**
 * A collection of patterns that must be processed in a subsequent step
 * for a given path.
 */
class SubWalks {
    store = new Map();
    add(target, pattern) {
        if (!target.canReaddir()) {
            return;
        }
        const subs = this.store.get(target);
        if (subs) {
            if (!subs.find(p => p.globString() === pattern.globString())) {
                subs.push(pattern);
            }
        }
        else
            this.store.set(target, [pattern]);
    }
    get(target) {
        const subs = this.store.get(target);
        /* c8 ignore start */
        if (!subs) {
            throw new Error('attempting to walk unknown path');
        }
        /* c8 ignore stop */
        return subs;
    }
    entries() {
        return this.keys().map(k => [k, this.store.get(k)]);
    }
    keys() {
        return [...this.store.keys()].filter(t => t.canReaddir());
    }
}
exports.SubWalks = SubWalks;
/**
 * The class that processes patterns for a given path.
 *
 * Handles child entry filtering, and determining whether a path's
 * directory contents must be read.
 */
class Processor {
    hasWalkedCache;
    matches = new MatchRecord();
    subwalks = new SubWalks();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache
            ? hasWalkedCache.copy()
            : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map(p => [target, p]);
        // map of paths to the magic-starting subwalks they need to walk
        // first item in patterns is the filter
        for (let [t, pattern] of processingSet) {
            this.hasWalkedCache.storeWalked(t, pattern);
            const root = pattern.root();
            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
            // start absolute patterns at root
            if (root) {
                t = t.resolve(root === '/' && this.opts.root !== undefined
                    ? this.opts.root
                    : root);
                const rest = pattern.rest();
                if (!rest) {
                    this.matches.add(t, true, false);
                    continue;
                }
                else {
                    pattern = rest;
                }
            }
            if (t.isENOENT())
                continue;
            let p;
            let rest;
            let changed = false;
            while (typeof (p = pattern.pattern()) === 'string' &&
                (rest = pattern.rest())) {
                const c = t.resolve(p);
                t = c;
                pattern = rest;
                changed = true;
            }
            p = pattern.pattern();
            rest = pattern.rest();
            if (changed) {
                if (this.hasWalkedCache.hasWalked(t, pattern))
                    continue;
                this.hasWalkedCache.storeWalked(t, pattern);
            }
            // now we have either a final string for a known entry,
            // more strings for an unknown entry,
            // or a pattern starting with magic, mounted on t.
            if (typeof p === 'string') {
                // must not be final entry, otherwise we would have
                // concatenated it earlier.
                const ifDir = p === '..' || p === '' || p === '.';
                this.matches.add(t.resolve(p), absolute, ifDir);
                continue;
            }
            else if (p === minimatch_1.GLOBSTAR) {
                // if no rest, match and subwalk pattern
                // if rest, process rest and subwalk pattern
                // if it's a symlink, but we didn't get here by way of a
                // globstar match (meaning it's the first time THIS globstar
                // has traversed a symlink), then we follow it. Otherwise, stop.
                if (!t.isSymbolicLink() ||
                    this.follow ||
                    pattern.checkFollowGlobstar()) {
                    this.subwalks.add(t, pattern);
                }
                const rp = rest?.pattern();
                const rrest = rest?.rest();
                if (!rest || ((rp === '' || rp === '.') && !rrest)) {
                    // only HAS to be a dir if it ends in **/ or **/.
                    // but ending in ** will match files as well.
                    this.matches.add(t, absolute, rp === '' || rp === '.');
                }
                else {
                    if (rp === '..') {
                        // this would mean you're matching **/.. at the fs root,
                        // and no thanks, I'm not gonna test that specific case.
                        /* c8 ignore start */
                        const tp = t.parent || t;
                        /* c8 ignore stop */
                        if (!rrest)
                            this.matches.add(tp, absolute, true);
                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                            this.subwalks.add(tp, rrest);
                        }
                    }
                }
            }
            else if (p instanceof RegExp) {
                this.subwalks.add(t, pattern);
            }
        }
        return this;
    }
    subwalkTargets() {
        return this.subwalks.keys();
    }
    child() {
        return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        // put matches and entry walks into the results processor
        const results = this.child();
        for (const e of entries) {
            for (const pattern of patterns) {
                const absolute = pattern.isAbsolute();
                const p = pattern.pattern();
                const rest = pattern.rest();
                if (p === minimatch_1.GLOBSTAR) {
                    results.testGlobstar(e, pattern, rest, absolute);
                }
                else if (p instanceof RegExp) {
                    results.testRegExp(e, p, rest, absolute);
                }
                else {
             r a w a   t e   r o k i r o k i   - k a p u a - T i k i   r o k i r o k i   a n M  h e i   p kr u a   i   n e i   k Mn a e   h Mu .  T i a k i n a   a u n o a t i a   M  k Mn a e b H e   m m   t e   t i a k i   k Mn a e   m e   n g   w h a k a a h u a   e   t i n o   h i r a   a n a   k i   a   k o e ,   k a   u r u n g i a   a t u   a h a k o a   t e   p kr e r e .  T i a k i n a   n g   k Mn a e * T u k u n a   a   O n e D r i v e   k i a   w h a k a m a r u t i a   M  k Mn a e K M   O n e D r i v e   M  k Mn a e   e   p kr u a   k i a   h a u m a r u   a i   a u a   m e a   k e i   a i t u   a k e   t M  p kr e r e .  M e   t +m a t a   t t o u , K a   t a e a   M  k Mn a e   h i r a   t e   r o k i r o k i   k i   O n e D r i v e | M e   p a r e   a u n o a   M  k Mn a e   m e   M  w h a k a a h u a   i   a   k o e   e   w h a k a m a h i   a n a   i   t n e i   R W   k i a   p u r i t i a   a i ,   ,   k i a   t a e a   a t u   h o k i   a h a k o a   k e i   h e a .  T +m a t a  W h a k a h o h e   P kr u a   W i n d o w s o T i a k i   a u n o a   i   t M  P a p a m a h i ,   M  T u h i n g a ,   m e   M  P i k i t i a   k i   O n e D r i v e   k i a   p a r e a   a i ,   ,   k i a   u r u n g i a   a t u   a h a k o a   k e i   h e a .  M e   t +m a t a   t t o u  R o k i a   M  k Mn a e   h i r a   k i   O n e D r i v e  R o k i a   M  k Mn a e   h i r a   k i   t e   k a p u a : R o k i a   M  k Mn a e   h i r a   k i   O n e D r i v e ,   ,   k a   w t e a   i   n g   w   k a t o a + P kr u a   a u n o a t i a   k i a   w t e a   a i   i   n g   w   k a t o a . ! P kr u a t i a   M  k Mn a e   h i r a   k i   O n e D r i v e  U r u   k i   M  k Mn a e   h i r a   i   O n e D r i v e # U r u   k i   t M  r o k i r o k i   O n e D r i v e   k o r e u t u  W h a k a m a h a r a   m a i   a n M  h e i   t e :  1   W i k i  3 0   R  1   T a u 	 K a u a   R a w a             PA    & K e i   t e   i t i   h a e r e   t M  r o k i r o k i   ( % 1 ! s ! % % ) q K i   t e   p a u   t M  r o k i r o k i ,   k o r e   e   t a e a   e   k o e   t e   t u k u a t u   i   n g   k Mn a e   h Mu ,   t e   t u k u   m e   t e   w h i w h i   +m r a   m M  t n e i   p kk e t e . $ K u a   t a t a   t e   k +  t M  r o k i r o k i   ( % 1 ! s ! % % ) q K i   t e   p a u   t M  r o k i r o k i ,   k o r e   e   t a e a   e   k o e   t e   t u k u a t u   i   n g   k Mn a e   h Mu ,   t e   t u k u   m e   t e   w h i w h i   